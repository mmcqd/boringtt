
let Bool : Type = ⊤ + ⊤
let tt : Bool = 1.<>
let ff : Bool = 2.<>
let Bool-Ind [P : Bool -> Type] [t : P tt] [f : P ff] [b : Bool] : P b =
  match b with
    | 1.x => match x with <> => t
    | 2.x => match x with <> => f

let if [A : Type] [b : Bool] [t : A] [f : A] : A =
  Bool-Ind (λ _ => A) t f b 


let ¬ [A : Type] : Type = A -> ⊥
  
let sym [A : Type] [x y : A] [x≡y : Id A x y] : Id A y x =
  match x≡y with
    | refl _ => refl _

let trans [A : Type] [x y z : A] [x≡y : Id A x y] [y≡z : Id A y z] : Id A x z =
  (match x≡y at x y _ => Id A y z -> Id A x z with
     | refl _ => λ eq => eq) y≡z


let coerce [A B : Type] [A≡B : Id Type A B] : A -> B =
  match A≡B with
    | refl _ => λ x => x


let subst [A : Type] [P : A -> Type] [x y : A] [x≡y : Id A x y] : P x -> P y =
  match x≡y with
    | refl _ => λ x => x


let cong [A B : Type] [f : A -> B] [x y : A] [x≡y : Id A x y] : Id B (f x) (f y) =
  match x≡y with
    | refl _ => refl _


let coerce-id [A B : Type] [A≡B : Id Type A B] [x y : A] [x≡y : Id A x y] : Id B (coerce A B A≡B x) (coerce A B A≡B y) =
  match x≡y with
    | refl _ => refl _

let Maybe [A : Type] : Type = A + One
let some [A : Type] [x : A] : Maybe A = 1.x
let none [A : Type] : Maybe A = 2.<>

let Maybe-Ind [A : Type] [P : Maybe A -> Type] [s : [x : A] -> P (some A x)] [n : P (none A)] [m : Maybe A] : P m =
  match m with
    | 1.x => s x
    | 2.x => match x with <> => n

let maybe [A B : Type] [s : A -> B] [n : B] [m : Maybe A] : B =
  Maybe-Ind A (λ _ => B) s n m


let ¬tt≡ff : ¬ (Id Bool tt ff) =
  λ tt≡ff => subst Bool (λ b => if^1 Type b One Zero) tt ff tt≡ff <>

let Pointed-Type : Type1 = [x : Type] × x

let Pointed-One : Pointed-Type = (One,<>)

let Pointed-Type0 : Pointed-Type^1 = (Type,One)

let Pointed-Type1 : Pointed-Type^2 = (Type1,Type)

let Loop [P : Pointed-Type] : Pointed-Type =
(Id P.1 P.2 P.2 , refl P.2)

let pointed≢Zero [A : Pointed-Type] [A≡Zero : Id Type A.1 Zero] : Zero =
coerce A.1 Zero A≡Zero A.2

let One≢Zero : Id Type One Zero -> Zero =
pointed≢Zero Pointed-One

let Contractible [A : Type] : Type1  = [x : A] × [y : A] -> Id A x y

let One-Contractible : Contractible One =
  (<> , λ x => match x with <> => refl <>)


let ⇔ [A B : Type] : Type = (A -> B) × (B -> A)

let ≃ [A B : Type] : Type1 =
[f : A -> B] × [g : B -> A] × ([x : A] -> Id A x (g (f x))) × ([y : B] -> Id B y (f (g y)))


let swap [A B : Type] : ≃ (A × B) (B × A) =
  (λ p => p.2 , p.1) ,
  (λ p => p.2 , p.1) ,
  (λ x => refl x) ,
  (λ x => refl x)

{-
let iso1 [A B : Type] : ≃ A (A × One)  =
  (λ x => x , <>) ,
  (λ p => p.1) ,
  (λ x => refl x) ,
  (λ p => _)
-}
