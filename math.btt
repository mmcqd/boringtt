

let sym [A : Type] [x y : A] [xâ‰¡y : Id A x y] : Id A y x =
  match xâ‰¡y with
    | refl x => refl

let trans [A : Type] [x y z : A] [xâ‰¡y : Id A x y] [yâ‰¡z : Id A y z] : Id A x z =
  (match xâ‰¡y at x y _ => Id A y z -> Id A x z with
     | refl x => Î» eq => eq) yâ‰¡z

let coerce [A B : Type] [Aâ‰¡B : Id Type A B] : A -> B =
  match Aâ‰¡B with
    | refl x => Î» x => x

let subst [A : Type] [P : A -> Type] [x y : A] [xâ‰¡y : Id A x y] : P x -> P y =
  match xâ‰¡y with
    | refl x => Î» x => x

let cong [A B : Type] [f : A -> B] [x y : A] [xâ‰¡y : Id A x y] : Id B (f x) (f y) =
  match xâ‰¡y with
    | refl x => refl

let coerce-id [A B : Type] [Aâ‰¡B : Id Type A B] [x y : A] [xâ‰¡y : Id A x y] : Id B (coerce A B Aâ‰¡B x) (coerce A B Aâ‰¡B y) =
  match xâ‰¡y with
    | refl x => refl

let Â¬ [A : Type] : Type = A -> âŠ¥

let ğŸš : Type = ğŸ™ + ğŸ™
let Bool : Type = ğŸš
let tt : Bool = 1.<>
let ff : Bool = 2.<>
let Bool-Ind [P : Bool -> Type] [t : P tt] [f : P ff] [b : Bool] : P b =
  match b with
    | 1._ => t
    | 2._ => f

let if [A : Type] [b : Bool] [t : A] [f : A] : A =
  Bool-Ind (Î» _ => A) t f b 

let Â¬ttâ‰¡ff : Â¬ (Id Bool tt ff) =
  Î» ttâ‰¡ff => subst Bool (Î» b => if^1 Type b ğŸ™ ğŸ˜) tt ff ttâ‰¡ff <>

let not [b : Bool] : Bool = if Bool b ff tt

let and [b1 b2 : Bool] : Bool =
  if Bool b1 b2 ff

let or [b1 b2 : Bool] : Bool =
  if Bool b1 tt b2

let not-id [b : Bool] : Id Bool b (not (not b)) = 
  match b with
    | 1.x => refl
    | 2.x => refl 


let de-morgan1 [p q : Bool] : Id Bool (not (or p q)) (and (not p) (not q)) =
  match p with
    | 1.x => 
      match q with
        | 1.y => refl
        | 2.y => refl
    | 2.x => 
      match q with
        | 1.y => refl
        | 2.y => refl

let de-morgan2 [p q : Bool] : Id Bool (not (and p q)) (or (not p) (not q)) =
  match p with
    | 1.x => 
      match q with
        | 1.y => refl
        | 2.y => refl
    | 2.x => 
      match q with
        | 1.y => refl
        | 2.y => refl


let Maybe [A : Type] : Type = A + ğŸ™
let some [A : Type] [x : A] : Maybe A = 1.x
let none [A : Type] : Maybe A = 2.<>

let Maybe-Ind [A : Type] [P : Maybe A -> Type] [s : [x : A] -> P (some A x)] [n : P (none A)] [m : Maybe A] : P m =
  match m with
    | 1.x => s x
    | 2._ => n

let maybe [A B : Type] [s : A -> B] [n : B] [m : Maybe A] : B =
  Maybe-Ind A (Î» _ => B) s n m

let Pointed-Type : Type^1 = [x : Type] Ã— x

let Pointed-ğŸ™ : Pointed-Type = (ğŸ™,<>)

let Pointed-Type0 : Pointed-Type^1 = (Type,ğŸ™)

let Pointed-TypeN : Pointed-Type^2 = (Type^1,Type)

let Loop [P : Pointed-Type] : Pointed-Type =
  (Id P.1 P.2 P.2 , refl)

let Â¬pointedâ‰¡âŠ¥ [A : Pointed-Type] : Â¬^1 (Id Type A.1 âŠ¥) =
  Î» Aâ‰¡âŠ¥ => coerce A.1 âŠ¥ Aâ‰¡âŠ¥ A.2

let Â¬âŠ¤â‰¡âŠ¥ : Â¬^1 (Id Type One Zero) =
  Â¬pointedâ‰¡âŠ¥ Pointed-ğŸ™

let Contractible [A : Type] : Type^1  = [x : A] Ã— [y : A] -> Id A x y

let ğŸ™-Contractible : Contractible ğŸ™ =
  (<> , Î» x => refl)

let â‡” [A B : Type] : Type = (A -> B) Ã— (B -> A)

let â‰ƒ [A B : Type] : Type^1 =
[f : A -> B] Ã— [g : B -> A] Ã— ([x : A] -> Id A x (g (f x))) Ã— ([y : B] -> Id B y (f (g y)))


let swapÃ— [A B : Type] : â‰ƒ (A Ã— B) (B Ã— A) =
  (Î» p => p.2 , p.1) ,
  (Î» p => p.2 , p.1) ,
  (Î» x => refl) ,
  (Î» x => refl)

let swap+ [A B : Type] : â‰ƒ (A + B) (B + A) =
  (Î» s => match s with 1.x => 2.x | 2.x => 1.x),
  (Î» s => match s with 1.x => 2.x | 2.x => 1.x),
  (Î» x => match x with 1.x => refl | 2.x => refl),
  (Î» x => match x with 1.x => refl | 2.x => refl)


let iso1 [A : Type] : â‰ƒ A (A Ã— ğŸ™) =
  (Î» x => x , <>) ,
  (Î» p => p.1) ,
  (Î» x => refl) ,
  (Î» p => refl)


let iso2 [A : Type] : â‰ƒ A (A + ğŸ˜) =
  (Î» a => 1.a),
  (Î» s => match s with 
    | 1.a => a 
    | 2.f => match f),
  (Î» x => refl),
  (Î» s => match s with
      | 1.a => refl
      | 2.b => match b)

let iso3 [A B : Type] : â‰ƒ^1 (â‰ƒ A B) (â‰ƒ B A) =
  (Î» p => p.2.1, p.1, p.2.2.2, p.2.2.1),
  (Î» p => p.2.1, p.1, p.2.2.2, p.2.2.1),
  (Î» x => refl),
  (Î» x => refl)

let iso4 [A : Type] : â‰ƒ A (ğŸ™ -> A) =
  (Î» a _ => a) ,
  (Î» t => t <>) ,
  (Î» a => refl) ,
  (Î» t => refl)

let iso5 [A : Type] : â‰ƒ (A + A) (ğŸš Ã— A) =
  (Î» s => match s with
    | 1.x => tt,x
    | 2.x => ff,x) ,
  (Î» p => if (A + A) p.1 (1.(p.2)) (2.(p.2)) ),
  (Î» s => match s with
    | 1.x => refl
    | 2.x => refl),
  (Î» p => match p.1 with
    | 1.x => refl
    | 2.x => refl)


{-
let âŠ [A B : Type] : Type = [b : Bool] Ã— if^1 Type b A B
let injâ‚ [A B : Type] [a : A] : âŠ A B = (tt , a)
let injâ‚‚ [A B : Type] [b : B] : âŠ A B = (ff , b)

let âŠ-Ind [A B : Type] [P : âŠ A B -> Type] [l : [x : A] -> P (injâ‚ A B x)] [r : [x : B] -> P (injâ‚‚ A B x)] [x : âŠ A B] : P x =
  _
-}