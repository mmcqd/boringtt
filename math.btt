
def id (A : Type) (x : A) : A = x

def sym (A : Type) (x y : A) (xâ‰¡y : Id A x y) : Id A y x =
  match xâ‰¡y with
    | refl x => refl

def trans (A : Type) (x y z : A) (xâ‰¡y : Id A x y) (yâ‰¡z : Id A y z) : Id A x z =
  (match xâ‰¡y at x y _ => Id A y z -> Id A x z with
     | refl x => Î» eq => eq) yâ‰¡z

def coerce (A B : Type) (Aâ‰¡B : Id Type A B) : A -> B =
  match Aâ‰¡B with
    | refl x => Î» x => x

def fam-id (A : Type) (B : A -> Type) (x y : A) (Î± : Id A x y) : Id Type (B x) (B y) =
  match Î± with
    | refl _ => refl

def dcoerce (A : Type) (B : A -> Type) (x y : A) (xâ‰¡y : Id A x y) : B x -> B y =
  match xâ‰¡y with
    | refl _ => Î» x => x


def subst (A : Type) (P : A -> Type) (x y : A) (xâ‰¡y : Id A x y) : P x -> P y =
  match xâ‰¡y with
    | refl x => Î» x => x

def cong (A B : Type) (f : A -> B) (x y : A) (xâ‰¡y : Id A x y) : Id B (f x) (f y) =
  match xâ‰¡y with
    | refl x => refl

def coerce-id (A B : Type) (Aâ‰¡B : Id Type A B) (x y : A) (xâ‰¡y : Id A x y) : Id B (coerce A B Aâ‰¡B x) (coerce A B Aâ‰¡B y) =
  match xâ‰¡y with
    | refl x => refl


def H-Id (A B : Type) (Aâ‰¡B : Id Type A B) (x : A) (y : B) : Type =
  Id B (coerce A B Aâ‰¡B x) y

def H-refl (A : Type) (x : A) : H-Id A A refl x x = refl

def H-sym (A B : Type) (Î± : Id Type A B) (x : A) (y : B) (Î² : H-Id A B Î± x y) : H-Id B A (sym^1 Type A B Î±) y x =
  match Î± with
    | refl A => 
      match Î² with
       | refl x => refl 


def Â¬ (A : Type) : Type = A -> âŠ¥

def âŠ¥-Ind (P : âŠ¥ -> Type) (x : âŠ¥) : P x = match x
  
def ðŸš : Type = ðŸ™ + ðŸ™
def Bool : Type = ðŸš
def tt : Bool = 1.()
def ff : Bool = 2.()
def Bool-Ind (P : Bool -> Type) (t : P tt) (f : P ff) (b : Bool) : P b = 
  match b with
    | 1._ => t
    | 2._ => f


def if (A : Type) (b : Bool) (t : A) (f : A) : A =
  Bool-Ind (Î» _ => A) t f b 

def Â¬ttâ‰¡ff : Â¬ (Id Bool tt ff) =
  Î» ttâ‰¡ff => subst Bool (Î» b => if^1 Type b ðŸ™ ðŸ˜) tt ff ttâ‰¡ff ()

def not (b : Bool) : Bool = if Bool b ff tt

def and (b1 b2 : Bool) : Bool =
  if Bool b1 b2 ff

def or (b1 b2 : Bool) : Bool =
  if Bool b1 tt b2

def not-id (b : Bool) : Id Bool b (not (not b)) = 
  match b with
    | 1.x => refl
    | 2.x => refl 


def de-morgan1 (p q : Bool) : Id Bool (not (or p q)) (and (not p) (not q)) =
  match p with
    | 1.x => refl
    | 2.x => 
      match q with
        | 1.x => refl
        | 2.x => refl

def de-morgan2 (p q : Bool) : Id Bool (not (and p q)) (or (not p) (not q)) =
  match p with
    | 1.x => refl
    | 2.x => refl


def Maybe (A : Type) : Type = A + ðŸ™
def some (A : Type) (x : A) : Maybe A = 1.x
def none (A : Type) : Maybe A = 2.()

def Maybe-Ind (A : Type) (P : Maybe A -> Type) (s : (x : A) -> P (some A x)) (n : P (none A)) (m : Maybe A) : P m =
  match m with
    | 1.a => s a
    | 2.b => n

def maybe (A B : Type) (s : A -> B) (n : B) (m : Maybe A) : B =
  Maybe-Ind A (Î» _ => B) s n m


def Pointed-Type : Type^1 = (x : Type) Ã— x

def Pointed-ðŸ™ : Pointed-Type = (ðŸ™,())

def Pointed-Type0 : Pointed-Type^1 = (Type,ðŸ™)

def Pointed-TypeN : Pointed-Type^2 = (Type^1,Type)

def Loop (P : Pointed-Type) : Pointed-Type =
  (Id P.1 P.2 P.2 , refl)

def Â¬pointedâ‰¡âŠ¥ (A : Pointed-Type) : Â¬^1 (Id Type A.1 âŠ¥) =
  Î» Aâ‰¡âŠ¥ => coerce A.1 âŠ¥ Aâ‰¡âŠ¥ A.2

def Â¬ðŸ™â‰¡ðŸ˜ : Â¬^1 (Id Type ðŸ™ ðŸ˜) =
  Â¬pointedâ‰¡âŠ¥ Pointed-ðŸ™

def Contractible (A : Type) : Type = (x : A) Ã— (y : A) -> Id A x y

def ðŸ™-Contractible : Contractible ðŸ™ =
  (() , Î» x => refl)

def â‡” (A B : Type) : Type = (A -> B) Ã— (B -> A)

def â‰ƒ (A B : Type) : Type =
(f : A -> B) Ã— (g : B -> A) Ã— ((x : A) -> Id A (g (f x)) x) Ã— ((y : B) -> Id B (f (g y)) y)


def iso/Ã—-comm (A B : Type) : â‰ƒ (A Ã— B) (B Ã— A) =
  (Î» p => (p.2 , p.1) ,
   Î» p => (p.2 , p.1) ,
   Î» x => refl ,
   Î» x => refl)


def iso/+-comm (A B : Type) : â‰ƒ (A + B) (B + A) =
  (Î» s => match s with 1.x => 2.x | 2.x => 1.x ,
   Î» s => match s with 1.x => 2.x | 2.x => 1.x ,
   Î» x => match x with 1.x => refl | 2.x => refl ,
   Î» x => match x with 1.x => refl | 2.x => refl)


def iso/Ã—-ident-r (A : Type) : â‰ƒ A (A Ã— ðŸ™) =
  (Î» x => (x , ()) ,
   Î» p => p.1 ,
   Î» x => refl ,
   Î» p => refl)

def iso/+-ident-r (A : Type) : â‰ƒ A (A + ðŸ˜) =
  (Î» a => 1.a,
   Î» s => match s with 
    | 1.a => a 
    | 2.f => match f ,
   Î» x => refl ,
   Î» s => match s with
      | 1.a => refl
      | 2.b => match b)

def iso/â‰ƒ-comm (A B : Type) : â‰ƒ^1 (â‰ƒ A B) (â‰ƒ B A) =
  (Î» p => (p.2.1, p.1, p.2.2.2, p.2.2.1) ,
   Î» p => (p.2.1, p.1, p.2.2.2, p.2.2.1) ,
   Î» x => refl ,
   Î» x => refl)


def iso/Ã—-destroy-r (A : Type) : â‰ƒ (A Ã— ðŸ˜) ðŸ˜ =
  (Î» p => p.2 ,
   Î» v => match v ,
   Î» p => match p.2 ,
   Î» v => match v)

def iso/exp-ident-r (A : Type) : â‰ƒ A (ðŸ™ -> A) =
  (Î» a _ => a  ,
   Î» t => t () ,
   Î» a => refl ,
   Î» t => refl)

def iso/sum-mul (A : Type) : â‰ƒ (A + A) (ðŸš Ã— A) =
  (Î» s => match s with
    | 1.x => (tt,x)
    | 2.x => (ff,x) ,
   Î» p => if (A + A) p.1 (1.(p.2)) (2.(p.2)) ,
   Î» s => match s with
    | 1.x => refl
    | 2.x => refl ,
   Î» p => match p.1 with
    | 1.x => refl
    | 2.x => refl)


def iso/Ã—-assoc (A B C : Type) : â‰ƒ (A Ã— (B Ã— C)) ((A Ã— B) Ã— C) =
  (Î» x => ((x.1,x.2.1),x.2.2) ,
   Î» x => (x.1.1,(x.1.2,x.2)),
   Î» _ => refl ,
   Î» _ => refl)


def iso/distrib (A B C : Type) : â‰ƒ (A Ã— (B + C)) ((A Ã— B) + (A Ã— C)) =
  (Î» p => match p.2 with
    | 1.b => 1.(p.1,b)
    | 2.c => 2.(p.1,c) ,
   Î» s => match s with
    | 1.p => (p.1,1.(p.2))
    | 2.p => (p.1,2.(p.2)),
   Î» p => match p.2 with
    | 1.a => refl
    | 2.b => refl ,
   Î» s => match s with
    | 1.p => refl
    | 2.p => refl)


def â‰ƒ-sym (A B : Type) (A2B : â‰ƒ A B) : â‰ƒ B A =
  (A2B.2.1,
   A2B.1,
   A2B.2.2.2,
   A2B.2.2.1)

def â‰ƒ-trans (A B C : Type) (A2B : â‰ƒ A B) (B2C : â‰ƒ B C) : â‰ƒ A C =
  (Î» a => B2C.1 (A2B.1 a),
   Î» c => A2B.2.1 (B2C.2.1 c) ,
   Î» x => 
    let eq = cong B A A2B.2.1 (B2C.2.1 (B2C.1 (A2B.1 x))) (A2B.1 x) (B2C.2.2.1 (A2B.1 x)) in
    trans A (A2B.2.1 (B2C.2.1 (B2C.1 (A2B.1 x)))) (A2B.2.1 (A2B.1 x)) x eq (A2B.2.2.1 x)
    ,
   Î» x =>
    let eq = cong B C B2C.1 (A2B.1 (A2B.2.1 (B2C.2.1 x))) (B2C.2.1 x) (A2B.2.2.2 (B2C.2.1 x)) in
    trans C (B2C.1 (A2B.1 (A2B.2.1 (B2C.2.1 x)))) (B2C.1 (B2C.2.1 x)) x eq (B2C.2.2.2 x)
  )


def Functor (F : Type -> Type) : Type^1 = (A B : Type) -> (A -> B) -> F A -> F B

def Maybe-F : Functor Maybe = fn A B f x => match x with 1.x => 1.(f x) | 2.x => 2.x

def EM : Type^1 = (A : Type) -> A + Â¬ A
def DNE : Type^1 = (A : Type) -> Â¬ (Â¬ A) -> A

def EM->DNE (em : EM) : DNE = 
  Î» A Â¬Â¬A => match em A with
    | 1.x => x
    | 2.x => match Â¬Â¬A x


def pair-ext (A B : Type) (p q : A Ã— B) (Î± : Id A p.1 q.1) (Î² : Id B p.2 q.2) : Id (A Ã— B) p q = 
  match Î± with
    | refl x => 
      match Î² with
        | refl y => refl



def cId (A : Type) (x y : A) : Type^1 = (P : A -> Type) -> P x -> P y

def crefl (A : Type) (x : A) : cId A x x = fn _ x => x

def equiv/Id-cId (A : Type) (x y : A) : â‡”^1 (Id A x y) (cId A x y) = 
  (Î» eq => match eq with refl x => fn _ x => x,Î» ceq => ceq (Î» z => Id A x z) refl)

{-
data Nat : Type =
  | zero
  | suc (n : Nat)

data List (A : Type) : Type =
  | nil
  | cons (x : A) (xs : List)

data Tree (A : Type) : Type =
  | empty
  | node (left : Tree) (x : A) (right : Tree)

data Sum (A B : Type) : Type =
  | in1 (a : A)
  | in2 (b : B)

Sum One One
-}
