
def id (A : Type) (x : A) : A = x

def sym (A : Type) (x y : A) (xâ‰¡y : Id A x y) : Id A y x =
  match xâ‰¡y with
    | refl x => refl

def trans (A : Type) (x y z : A) (xâ‰¡y : Id A x y) (yâ‰¡z : Id A y z) : Id A x z =
  (match xâ‰¡y at x y _ => Id A y z -> Id A x z with
     | refl x => Î» eq => eq) yâ‰¡z

def coerce (A B : Type) (Aâ‰¡B : Id Type A B) : A -> B =
  match Aâ‰¡B with
    | refl x => Î» x => x

def fam-id (A : Type) (B : A -> Type) (x y : A) (Î± : Id A x y) : Id Type (B x) (B y) =
  match Î± with
    | refl _ => refl

def dcoerce (A : Type) (B : A -> Type) (x y : A) (xâ‰¡y : Id A x y) : B x -> B y =
  match xâ‰¡y with
    | refl _ => Î» x => x

def subst (A : Type) (P : A -> Type) (x y : A) (xâ‰¡y : Id A x y) : P x -> P y =
  match xâ‰¡y with
    | refl x => Î» x => x

def cong (A B : Type) (f : A -> B) (x y : A) (xâ‰¡y : Id A x y) : Id B (f x) (f y) =
  match xâ‰¡y with
    | refl x => refl

def coerce-id (A B : Type) (Aâ‰¡B : Id Type A B) (x y : A) (xâ‰¡y : Id A x y) : Id B (coerce A B Aâ‰¡B x) (coerce A B Aâ‰¡B y) =
  match xâ‰¡y with
    | refl x => refl


def Â¬ (A : Type) : Type = A -> âŠ¥

def âŠ¥-Ind (P : âŠ¥ -> Type) (x : âŠ¥) : P x = match x
  
def ğŸš : Type = ğŸ™ + ğŸ™
def Bool : Type = ğŸš
def tt : Bool = 1.<>
def ff : Bool = 2.<>
def Bool-Ind (P : Bool -> Type) (t : P tt) (f : P ff) (b : Bool) : P b = 
  match b with
    | 1._ => t
    | 2._ => f


def if (A : Type) (b : Bool) (t : A) (f : A) : A =
  Bool-Ind (Î» _ => A) t f b 

def Â¬ttâ‰¡ff : Â¬ (Id Bool tt ff) =
  Î» ttâ‰¡ff => subst Bool (Î» b => if^1 Type b ğŸ™ ğŸ˜) tt ff ttâ‰¡ff <>

def not (b : Bool) : Bool = if Bool b ff tt

def and (b1 b2 : Bool) : Bool =
  if Bool b1 b2 ff

def or (b1 b2 : Bool) : Bool =
  if Bool b1 tt b2

def not-id (b : Bool) : Id Bool b (not (not b)) = 
  match b with
    | 1.x => refl
    | 2.x => refl 


def de-morgan1 (p q : Bool) : Id Bool (not (or p q)) (and (not p) (not q)) =
  match p with
    | 1.x => refl
    | 2.x => 
      match q with
        | 1.x => refl
        | 2.x => refl

def de-morgan2 (p q : Bool) : Id Bool (not (and p q)) (or (not p) (not q)) =
  match p with
    | 1.x => refl
    | 2.x => refl


def Maybe (A : Type) : Type = A + ğŸ™
def some (A : Type) (x : A) : Maybe A = 1.x
def none (A : Type) : Maybe A = 2.<>

def Maybe-Ind (A : Type) (P : Maybe A -> Type) (s : (x : A) -> P (some A x)) (n : P (none A)) (m : Maybe A) : P m =
  match m with
    | 1.a => s a
    | 2.b => n

def maybe (A B : Type) (s : A -> B) (n : B) (m : Maybe A) : B =
  Maybe-Ind A (Î» _ => B) s n m

def Pointed-Type : Type^1 = (x : Type) Ã— x

def Pointed-ğŸ™ : Pointed-Type = (ğŸ™,<>)

def Pointed-Type0 : Pointed-Type^1 = (Type,ğŸ™)

def Pointed-TypeN : Pointed-Type^2 = (Type^1,Type)

def Loop (P : Pointed-Type) : Pointed-Type =
  (Id P.1 P.2 P.2 , refl)

def Â¬pointedâ‰¡âŠ¥ (A : Pointed-Type) : Â¬^1 (Id Type A.1 âŠ¥) =
  Î» Aâ‰¡âŠ¥ => coerce A.1 âŠ¥ Aâ‰¡âŠ¥ A.2

def Â¬ğŸ™â‰¡ğŸ˜ : Â¬^1 (Id Type ğŸ™ ğŸ˜) =
  Â¬pointedâ‰¡âŠ¥ Pointed-ğŸ™

def Contractible (A : Type) : Type = (x : A) Ã— (y : A) -> Id A x y

def ğŸ™-Contractible : Contractible ğŸ™ =
  (<> , Î» x => refl)

def â‡” (A B : Type) : Type = (A -> B) Ã— (B -> A)

def â‰ƒ (A B : Type) : Type =
(f : A -> B) Ã— (g : B -> A) Ã— ((x : A) -> Id A (g (f x)) x) Ã— ((y : B) -> Id B (f (g y)) y)


def iso/Ã—-comm (A B : Type) : â‰ƒ (A Ã— B) (B Ã— A) =
  (Î» p => p.2 , p.1) ,
  (Î» p => p.2 , p.1) ,
  (Î» x => refl) ,
  (Î» x => refl)

def iso/+-comm (A B : Type) : â‰ƒ (A + B) (B + A) =
  (Î» s => match s with 1.x => 2.x | 2.x => 1.x),
  (Î» s => match s with 1.x => 2.x | 2.x => 1.x),
  (Î» x => match x with 1.x => refl | 2.x => refl),
  (Î» x => match x with 1.x => refl | 2.x => refl)


def iso/Ã—-ident-r (A : Type) : â‰ƒ A (A Ã— ğŸ™) =
  (Î» x => x , <>) ,
  (Î» p => p.1) ,
  (Î» x => refl) ,
  (Î» p => refl)

def iso/+-ident-r (A : Type) : â‰ƒ A (A + ğŸ˜) =
  (Î» a => 1.a),
  (Î» s => match s with 
    | 1.a => a 
    | 2.f => match f),
  (Î» x => refl),
  (Î» s => match s with
      | 1.a => refl
      | 2.b => match b)

def iso/â‰ƒ-comm (A B : Type) : â‰ƒ^1 (â‰ƒ A B) (â‰ƒ B A) =
  (Î» p => p.2.1, p.1, p.2.2.2, p.2.2.1),
  (Î» p => p.2.1, p.1, p.2.2.2, p.2.2.1),
  (Î» x => refl),
  (Î» x => refl)

def iso/Ã—-destroy-r (A : Type) : â‰ƒ (A Ã— ğŸ˜) ğŸ˜ =
  (Î» p => p.2),
  (Î» v => match v),
  (Î» p => match p.2),
  (Î» v => match v)

def iso/exp-ident-r (A : Type) : â‰ƒ A (ğŸ™ -> A) =
  (Î» a _ => a) ,
  (Î» t => t <>) ,
  (Î» a => refl) ,
  (Î» t => refl)

def iso/sum-mul (A : Type) : â‰ƒ (A + A) (ğŸš Ã— A) =
  (Î» s => match s with
    | 1.x => tt,x
    | 2.x => ff,x) ,
  (Î» p => if (A + A) p.1 (1.(p.2)) (2.(p.2)) ),
  (Î» s => match s with
    | 1.x => refl
    | 2.x => refl),
  (Î» p => match p.1 with
    | 1.x => refl
    | 2.x => refl)


def iso/Ã—-assoc (A B C : Type) : â‰ƒ (A Ã— (B Ã— C)) ((A Ã— B) Ã— C) =
  (Î» x => (x.1,x.2.1),x.2.2),
  (Î» x => (x.1.1,(x.1.2,x.2))),
  (Î» _ => refl),
  (Î» _ => refl)

def iso/distrib (A B C : Type) : â‰ƒ (A Ã— (B + C)) ((A Ã— B) + (A Ã— C)) =
  (Î» p => match p.2 with
    | 1.b => 1.(p.1,b)
    | 2.c => 2.(p.1,c)),
  (Î» s => match s with
    | 1.p => p.1,1.(p.2)
    | 2.p => p.1,2.(p.2)),
  (Î» p => match p.2 with
    | 1.a => refl
    | 2.b => refl),
  (Î» s => match s with
    | 1.p => refl
    | 2.p => refl)

def â‰ƒ-sym (A B : Type) (A2B : â‰ƒ A B) : â‰ƒ B A =
  A2B.2.1,
  A2B.1,
  A2B.2.2.2,
  A2B.2.2.1

def â‰ƒ-trans (A B C : Type) (A2B : â‰ƒ A B) (B2C : â‰ƒ B C) : â‰ƒ A C =
  (Î» a => B2C.1 (A2B.1 a)),
  (Î» c => A2B.2.1 (B2C.2.1 c)),
  (Î» x =>
    let eq = cong B A A2B.2.1 (B2C.2.1 (B2C.1 (A2B.1 x))) (A2B.1 x) (B2C.2.2.1 (A2B.1 x)) in
    trans A (A2B.2.1 (B2C.2.1 (B2C.1 (A2B.1 x)))) (A2B.2.1 (A2B.1 x)) x eq (A2B.2.2.1 x)
  ) ,
  (Î» x =>
    let eq = cong B C B2C.1 (A2B.1 (A2B.2.1 (B2C.2.1 x))) (B2C.2.1 x) (A2B.2.2.2 (B2C.2.1 x)) in
    trans C (B2C.1 (A2B.1 (A2B.2.1 (B2C.2.1 x)))) (B2C.1 (B2C.2.1 x)) x eq (B2C.2.2.2 x)
  )


def Functor : Type^1 = (F : Type -> Type) Ã— (A B : Type) -> (A -> B) -> F A -> F B

def Maybe-F : Functor = Maybe, fn A B f x => match x with 1.x => 1.(f x) | 2.x => 2.x

def EM : Type^1 = (A : Type) -> A + Â¬ A
def DNE : Type^1 = (A : Type) -> Â¬ (Â¬ A) -> A

def EM->DNE (em : EM) : DNE = 
  Î» A Â¬Â¬A => match em A with
    | 1.x => x
    | 2.x => match Â¬Â¬A x

{-
def DNE->EM (dne : DNE) : EM =
  Î» A => dne (A + Â¬ A) (Î» Â¬em => ?)
-}

def pair-ext (A B : Type) (p q : A Ã— B) (Î± : Id A p.1 q.1) (Î² : Id B p.2 q.2) : Id (A Ã— B) p q = 
  match Î± with
    | refl _ =>
      match Î² with
        | refl _ => refl

axiom ğŸ› : Type
axiom aa : ğŸ›
axiom bb : ğŸ›
axiom cc : ğŸ›
